# Program defaults for all available options
#
# !! DO NOT MODIFY !!
#
# This file will be overwritten in updates.
#
# Set customized options for the running environment
# in site.ini in the script directory, and job specific
# options in job.ini in the working directory.
#
# Acceptable boolean values (case-insensitive) are True,
# yes, on, 1 and False, no, off, 0


# Method for calculating charge. [str] {repeat, gulp}
charge_method = repeat
# Use a a specific queue when submitting jobs. Leave blank for none [str]
dedicated_queue =
# Cell parameters to use only when they are not specified in the input
# structure. Use either (a, b, c, alpha, beta, gamma) or
#    ax, ay, az,
#    bx, by, bz,
#    cx, cy, cz
# notation. [float, list]
default_cell = (10.0, 10.0, 10.0, 90, 90, 90)
# Method to use for dft and/or optimization step. [str] {vasp, siesta}
dft_code = vasp
# Turn on empirical dispersion corrections in dft codes that
# support it. [bool]
dispersion = True
# Location of Eugenes QEq code [str]
egulp_exe = egulp
# custom parameter sets for QEq as (atom, electronegativity, 0.5*hardness) [(int/str, float, float), list]
egulp_parameters =
# Resolution of the esp grid (A). [float]
esp_resolution = 0.1
# Source for the ESP. This will usually be the same as the dft_code,
# but not always. [str] {vasp, siesta}
esp_src = vasp
# files to keep and compress after a successful fastmc job [str, list]
fastmc_compress_files = *.cube
# files to delete after a successful fastmc job [str, list]
fastmc_delete_files =
# Location of fastmc executable, must be the full path or be in the
# user's $PATH. [str]
fastmc_exe = fastmc
# Should the original cube files be kept after folding (or deleted)? [bool]
fastmc_keep_unfolded_cubes = False
# Number of CPUs to run fastmc on. Make sure that you use the
# correct fastmc_exe for parallel runs. [int]
fastmc_ncpu = 1
# Method to use to do force field optimisations [str]
ff_opt_code = gulp
# Calculate the location of the guests from the probability cube [bool]
find_maxima = True
# Fold probability cube into the unit cell [bool]
fold = True
# Guest(s) to use in GCMC. [str, list] {see guests.lib}
guests = CO2
# Location of GULP exe [str]
gulp_exe = gulp
# Try to read in data from a previous calculation. [bool]
import = False
# Filetype for input structure file. [str] {pdb, cif, vasp, xyz}
initial_structure_format = cif
# Enable interactive interface. [bool]
interactive = False
# Kpoint grid size for dft calculations. Ensure that gamma-point only
# exe is not used for >1 kpoint. [(int, int, int)]
kpoints = (1, 1, 1)
# Method to use for Monte Carlo calculations. [str] {fastmc}
mc_code = fastmc
# Potential cutoff to use in GCMC. This will also be used to determine
# the minimum supercell size. [float]
mc_cutoff = 12.5
# GCMC equilibration steps. [int]
mc_eq_steps = 1000000
# How often to write the fastmc history. [int]
mc_history_freq = 0
# Add the 'jobcontrol' directive with fastmc so that GCMC must be
# stopped manually. [bool]
mc_jobcontrol = False
# How often to write the fastmc numguests. [int]
mc_numguests_freq = 1000
# GCMC pressure(s) (bar). For multiple pressure points and guests use
# nested lists ((g1p1, g2p1, ...), (g1p2, g2p2, ...), ...), these are
# all run at every temperature to generate isotherms [float, list]
mc_pressure = 0.14
# Turn on probability plots in GCMC. [bool]
mc_probability_plot = True
# Distance between grid points (resolution) for GCMC probability plot. [float]
mc_probability_plot_spacing = 0.1
# GCMC production steps. [int]
mc_prod_steps = 10000000
# Individual state points to run gcmc simulations; not combined with
# temperature/pressure isotherms. Specify points (bar/Kelvin) as:
# (T1, (g1p1, g2p1, ...)), (T2, (g1p2, g2p2, ...), ... [float, list]
mc_state_points =
# Supercell to use for GCMC. These values will only be used if the
# individual dimenstions are larger than the supercell calculated from
# the cutoff. [(int, int, int)]
mc_supercell = (1, 1, 1)
# Temperature(s) to use in GCMC (Kelvin) combined with pressures to
# collect isotherms. [float, list]
mc_temperature = 313
# Skip the charge calculation step; Charges will all be zero. [bool]
no_charges = False
# Skip the dft/optimization step; structure is not optimized and charge
# calculation may fail if it depends on this step. [bool]
no_dft = False
# Do not pre-optimise with a force field [bool]
no_force_field_opt = True
# Skip the gcmc step. [bool]
no_gcmc = False
# Skip the property calculations. [bool]
no_properties = False
# Do not submit jobs; just create input files. [bool]
no_submit = False
# Optimize positions of hydrogens in dft/optimization step. [bool]
optim_h = True
# Optimize all atom positions in dft/optimization step. [bool]
optim_all = False
# Optimize cell vectors in dft/optimization step. [bool]
optim_cell = False
# Do not colourise output. Ignored here; use commandline. [bool]
plain = False
# Location of VASP POTCARs; each element in a folder. [str]
potcar_dir = vasp_pseudopotentials/
# Location of siesta psf pseudopotentials. [str]
psf_dir = siesta_pseuodpotentials/
# Fit charge equilibration parameters to calculated charges. [bool]
qeq_fit = False
# Queuing system to use. [str] {wooki, sharcnet}
queue = wooki
# Only output errors. This will be ignored here; set on commandline. [bool]
quiet = False
# files to keep and compress after a successful REPEAT job [str, list]
repeat_compress_files = *.cube
# files to delete after a successful REPEAT job [str, list]
repeat_delete_files = ESP_real_coul.dat fort.30 fort.40 REPEAT_param.inp
# Location of REPEAT executable. [str]
repeat_exe = repeat.x
# Cpus to use for REPEAT calculation. Ensure that repeat_exe points to a
# parallel version if using more than one CPU. [int]
repeat_ncpu = 1
# Run all the steps without stopping. [bool]
run_all = True
# Maximum memory that can be used for serial calculations (GB). [float]
serial_memory = 2.5
# General acucracy setting for siesta calcualtions. [str] {low, med, high}
siesta_accuracy = med
# Files to keep and compress after a successful SIESTA job [str, list]
siesta_compress_files =
# Files to delete after a successful SIESTA job [str, list]
siesta_delete_files = *.ion *.xml INPUT_TMP* *.DM
# Location of siesta executable. [str]
siesta_exe = siesta
# Number of CPUs to use for siesta. [str]
siesta_ncpu = 1
# Command to convert siesta ESP to .cube file. [str]
siesta_to_cube = siesta2repeat
# Only emit critical messages. Ignored here; use commandline. [bool]
silent = False
# Turn on spin polarization in dft. [bool]
spin = False
# Radius of probe for calculating surface areas. A probe of radius 0.0 will
# generate the VdW surface typical values for probe molecules are 1.42 (H2),
# 1.72 (CO2) or 1.82 (N2) (A). [float, list]
surface_area_probe =
# Approximate area per point when subdividing accessible surface areas (A^2).
surface_area_resolution = 0.03
# Save the valid points on the surface to a file. [bool]
surface_area_save = False
# Use points with a uniform spacing? (or do Monte Carlo sampling) [bool]
surface_area_uniform_sample = False
# Treat symmetrical atoms as equivalent for charges. [bool]
symmetry = False
# Bundle all the output into an archive when the job is finished [bool]
tar_after = False
# Extract all the tarred files before starting (useful for import) [bool]
tar_extract_before = False
# Codes that run with openmp threads, not mpi. [str, list]
threaded_codes = repeat
# Maximum memory to use for threaded calculations (GB). [float]
threaded_memory = 12
# Re-read options on restart. [bool]
update_opts = True
# files to keep and compress after a successful VASP job [str, list]
vasp_compress_files = LOCPOT CHGCAR vasprun.xml
# files to delete after a successful VASP job [str, list]
vasp_delete_files = WAVECAR CHG DOSCAR EIGENVAL POTCAR PCDAT IBZKPT XDATCAR KPOINTS
# Name (location) of vasp executable. [str]
vasp_exe = vasp
# Number of cpus to run vasp on. [int]
vasp_ncpu = 8
# Command to convert LOCPOT to .cube for REPEAT [str]
vasp_to_cube = vasp_to_cube
# Print debugging information. This will be ignored here; set on commandline.
verbose = False
# Run zeo++ on the structure? [bool]
zeo++ = True
# Command to run for zeo++. Include all required options here but omit the
# cssr name. Radius (-r) and mass (-mass) files are automatically added. [str]
zeo++_exe = network

#
# Function switch specific options
#

# Run fapswitch as a service and wait for line-by-line input.
# See also commandline options [bool]
daemon = False
# Backends to store the output structures {file, sqlite}
fapswitch_backends = file
# Where to get the connectivity information from [str] {openbabel, file}
fapswitch_connectivity = openbabel
# Make functionalisations with the set of {.freeform.srings.} and
# [symm@try.strings][str]
fapswitch_custom_strings =
# Number of completely randomised structures to make [int]
fapswitch_full_random_count = 0
# Maximum number of groups that will be used simultaneously [int]
fapswitch_max_different = 0
# Socket port to run the server mode on; leave as zero to pick random
# available port as two instances cannot share a port [int]
fapswitch_port = 0
# Should fapswitch produce all group@site combinations? [bool]
fapswitch_replace_all_sites = False
# Only use the specified groups in systematic functionalisations [list]
fapswitch_replace_groups =
# Only replace the listed sites in systematic functionalisations [list]
fapswitch_replace_only =
# Number of symmetry based randomised structures to make [int]
fapswitch_site_random_count = 0
# Probability that a site will have no functionalisation in random switching
# scheme [float]
fapswitch_unfunctionalised_probability = 0.5
