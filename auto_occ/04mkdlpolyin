#! /usr/bin/env python

import sys
import os
import time
import scipy
import numpy
from JOB_OPTIONS import *

pid = str(os.getpid())


EXIT_SUCCESS = 0
EXIT_FAILURE = 1

usage  = '''
---------------------------------------------------
Usage:
04mkdlpolyin [CPMD INPUT filename]
---------------------------------------------------
'''


#check if there are enough arguments in the call to main
if(len(sys.argv) != 2):
    print " ["+pid+"] "+time.ctime()+ "| "+"Too many/few Arguments"
    print " ["+pid+"] "+time.ctime()+ "| "+usage
    sys.exit(EXIT_FAILURE)

dump = True
basevars = dir()

def vardump(newvars):
    if dump:
	for varname in basevars:
            newvars.remove(str(varname))
        for possiblefunction in newvars:
            if str(eval(str(possiblefunction))).__contains__("0x"):
                newvars.remove(str(possiblefunction))
        for possiblefunction in newvars:
            if str(eval(str(possiblefunction))).__contains__("0x"):
                newvars.remove(str(possiblefunction))
        for newvarname in newvars:
            print "#dump#%(name)35s evaluates to | %(eval)35s" % {'name':newvarname,'eval':eval(newvarname)}


#grid resolution and neighbour distance criteria for iGuest pocket search
DLPOLY_GUEST_GRIDPOINTS = float(init_variable("DLPOLY_GUEST_GRIDPOINTS"))
DLPOLY_MIN_GUEST_DISTANCE = float(init_variable("DLPOLY_MIN_GUEST_DISTANCE"))


#List of atomic weights in g/mol used for generation of FIELD file
Weights =[["H",1.00794], ["He",4.002602], ["Li",6.941], ["Be",9.012182], ["B",10.811], ["C",12.0107], ["N",14.0067], ["O",15.9994], ["F",18.9984032], 
["Ne",20.1797], ["Na",22.98976928], ["Mg",24.3050], ["Al",26.9815386], ["Si",28.0855], ["P",30.973762], ["S",32.065], ["Cl",35.453], ["Ar",39.948], 
["K",39.0983], ["Ca",40.078], ["Sc",44.955912], ["Ti",47.867], ["V",50.9415], ["Cr",51.9961], ["Mn",54.938045], ["Fe",55.845], ["Co",58.933195], 
["Ni",58.6934], ["Cu",63.546], ["Zn",65.38], ["Ga",69.723], ["Ge",72.64], ["As",74.92160], ["Se",78.96], ["Br",79.904], ["Kr",83.798], ["Rb",85.4678], 
["Sr",87.62], ["Y",88.90585], ["Zr",91.224], ["Nb",92.90638], ["Mo",95.96], ["Tc",98], ["Ru",101.07], ["Rh",102.90550], ["Pd",106.42], ["Ag",107.8682], 
["Cd",112.411], ["In",114.818], ["Sn",118.710], ["Sb",121.760], ["Te",127.60], ["I",126.90447], ["Xe",131.293], ["Cs",132.9054519], ["Ba",137.327], 
["La",138.90547], ["Ce",140.116], ["Pr",140.90765], ["Nd",144.242], ["Pm",145], ["Sm",150.36], ["Eu",151.964], ["Gd",157.25], ["Tb",158.92535], 
["Dy",162.500], ["Ho",164.93032], ["Er",167.259], ["Tm",168.93421], ["Yb",173.054], ["Lu",174.9668], ["Hf",178.49], ["Ta",180.94788], ["W",183.84], 
["Re",186.207], ["Os",190.23], ["Ir",192.217], ["Pt",195.084], ["Au",196.966569], ["Hg",200.59], ["Tl",204.3833], ["Pb",207.2], ["Bi",208.98040], 
["Po",209], ["At",210], ["Rn",222], ["Fr",223], ["Ra",226], ["Ac",227], ["Th",232.03806], ["Pa",231.03588], ["U",238.02891], ["Np",237], ["Pu",244], 
["Am",243], ["Cm",247], ["Bk",247], ["Cf",251], ["Es",252], ["Fm",257], ["Md",258], ["No",259], ["Lr",262], ["Rf",265], ["Db",268], ["Sg",271], 
["Bh",272], ["Hs",270], ["Mt",276], ["Ds",281], ["Rg",280], ["Cn",285], ["Uut",284], ["Uuq",289], ["Uup",288], ["Uuh",293], ["Uuo",294]]

#function to return specific VDW value stored in vdw_vals
def getvdwline(choice):
    gotVDW = 0;
    if len(vdw_vals) == 0:
        print " ["+pid+"] "+time.ctime()+ "| "+"Error interpreting VDW values."
        sys.exit(EXIT_FAILURE)
    for i in range(len(vdw_vals)):
        if(vdw_vals[i][0]==choice):
          gotVDW = 1
          return vdw_vals[i]
    if not(gotVDW):
      print " ["+pid+"] "+time.ctime()+ "| "+"vDW values missing for " + choice 


###REPEATED defs from previous script 01mkcpmdin

#Element list for reduction
#You may want to pull one of these elements in the event that your input labels include Carbons named Ca or something analogous.

elements = ["H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar",
            "K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br",
            "Kr","Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te",
            "I","Xe","Cs","Ba","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm",
            "Yb","Lu","Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Th","Pa","U",
            "Po","At","Rn","Fr","Ra","Ac","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr",
            "Rf","Db","Sg","Bh","Hs","Mt"]

#Function to Character-interatively replace labels by closest progressive match
def relabel(old_list,labels):
    recovery = 0.0
    for i in range(len(old_list)):
        found = 0
        for j in range(len(labels)):
            if old_list[i][:2][0].upper() == labels[j].upper():
                old_list[i] = labels[j]
                found = 1
        if not(found):
            for j in range(len(labels)):
                if old_list[i][0][:1].upper() == labels[j].upper():
                    old_list[i] = labels[j]
                    found = 1
            if found == 0:
                print " ["+pid+"] "+time.ctime()+ "| "+"Convenient Label not found for "+str(old_list[i])    
        recovery += found
    recovery/=float(len(old_list))
    if recovery < 1.0:
        print " ["+pid+"] "+time.ctime()+ "| "+"Not all atoms could be converted to appropriate labels"
        sys.exit(EXIT_FAILURE)

#Determine the minimal set of unique labels
def uniqify(coords):
    natoms = len(coords)
    atom_labels = []
    if natoms == 0:
        print " ["+pid+"] "+time.ctime()+ "| "+"No Atoms passed to function \"uniqify\""
        sys.exit(EXIT_FAILURE)
    for i in range(natoms):
        Found = "0"
        for j in range(len(atom_labels)):
            if (coords[i] == atom_labels[j]):
                Found = "1"
        if (Found != "1"):
            atom_labels.append(coords[i])
    return atom_labels

### End of REPEATED defs from previous script 01mkcpmdin


#Replace with dictionary of key/value pairs.

#function to look up weight of specific atom type
def lookupwt(atom):
    molw = ""
    for i in range(len(Weights)):
        if (Weights[i][0] == atom):
            molw = Weights[i][1] 
    return molw



new_index = []
rpt_charges = []


MAIN_GCMC_PACKAGE =init_variable("MAIN_GCMC_PACKAGE")

#FIELD parameters
DLPOLY_MOL_TYPES = init_variable("DLPOLY_MOL_TYPES")


#Supercell size ([x,y,z])



DLPOLY_SUPERCELL_DIM_A = int(init_variable("DLPOLY_SUPERCELL_DIM_A"))
DLPOLY_SUPERCELL_DIM_B = int(init_variable("DLPOLY_SUPERCELL_DIM_B"))
DLPOLY_SUPERCELL_DIM_C = int(init_variable("DLPOLY_SUPERCELL_DIM_C"))
DLPOLY_SUPERCELL_DIMS = [DLPOLY_SUPERCELL_DIM_A,DLPOLY_SUPERCELL_DIM_B,DLPOLY_SUPERCELL_DIM_C]



#DL_POLY parameters for CONFIG file periodicity and inclusions
#NOTE DLPOLY_LEVCFG will never change unless the script does.
#NOTE DLPOLY_IMCON depicts the nature of the periodic boundary conditions
# Refer to DL_POLY manual, Table 4.6 (periodic boundary key) for values

DLPOLY_LEVCFG = int(init_variable("DLPOLY_LEVCFG"))

DLPOLY_IMCON = int(init_variable("DLPOLY_IMCON"))


#popen to pull in charge lines from REPEAT output
f1=os.popen("grep Charge rpt_out",'r')

f2=open('GEOMETRY.xyz','r')
f3=open('ORDER_'+sys.argv[1],'r')

#popen unit cell vectors from CPMD input file
f4=os.popen('grep VECTOR -A 3 '+sys.argv[1]+'.in | grep -v VECTOR','r')

DLPOLY_VDW_FILE = init_variable("DLPOLY_VDW_FILE")
DLPOLY_GUEST_FILE = init_variable("DLPOLY_GUEST_FILE")

try:
    VDW_FILE=open(DLPOLY_VDW_FILE,'r')
except:
    print " ["+pid+"] "+time.ctime()+ "| "+"Cannot open DLY_VDW_FILE."
    sys.exit(EXIT_FAILURE)

CONFIG_FILE=open('CONFIG','w')
FIELD_FILE=open('FIELD','w')
try:
    GUEST_FILE=open(DLPOLY_GUEST_FILE,'r')
except:
    print " ["+pid+"] "+time.ctime()+ "| "+"Cannot open DLPOLY_GUEST_FILE."
    sys.exit(EXIT_FAILURE)


lines = f1.readlines()

#Parse and store charges from REPEAT OUTPUT

#PB -- added some stuff to make sure the total system charge = 0 for DL_POLY run
#      this adjustment only works if there are enough atoms in the unit cell\
#      to adjust the partial charges by +/- 0.0001 to make it charge neutral
#DV -- I've edited the code so that it will do complete loops of the system 
#      in the event that the charge difference / 0.0001 is larger than the number
#      of atoms in the systems.  ie.  It will work for small systems too now.

for i in range(len(lines)):
    if len(lines[i].split())>0 and (lines[i].split()[0].upper()=="CHARGE"):
        rpt_charges.append(float('%9.4f'%float(lines[i].split()[6])))

net_charge=numpy.sum(rpt_charges)
adjust=int(numpy.round(numpy.sum(rpt_charges)/1e-4))
adj_value=numpy.sign(-1*adjust)*1e-4
if net_charge != 0:
    print " ["+pid+"] "+time.ctime()+ "| "+"WARNING - total system charge of ", net_charge
    print " ["+pid+"] "+time.ctime()+ "| "+"adjusting the first",abs(adjust),"atom charges by",adj_value

natoms = len(rpt_charges)
if natoms < adjust:
    full_increm_cycles = int(adjust)/int(natoms)
    last_increm_cycle = int(((float(adjust)/natoms) - int((float(adjust)/natoms)))*natoms)
    for j in range(full_increm_cycles):
         for i in range(abs(adjust)):
             rpt_charges[i]=rpt_charges[i]+adj_value
    for j in range(last_increm_cycle):
         for i in range(abs(adjust)):
             rpt_charges[i]=rpt_charges[i]+adj_value
else:
    for i in range(abs(adjust)):
        rpt_charges[i]=rpt_charges[i]+adj_value


# check to see if the charges are net neutral
new_charge=round(numpy.sum(rpt_charges))
if new_charge != 0:
    print " ["+pid+"] "+time.ctime()+ "| "+"WARNING -- the adjusted REPEAT charges still sum to",new_charge
    print " ["+pid+"] "+time.ctime()+ "| "+"Please fix this in the FIELD file in the original/ directory"

#Pull in coordinates from GEOMETRY file read and sort out
f2.readline()
f2.readline()
coords = f2.readlines()

if len(coords) == 0:
    print " ["+pid+"] "+time.ctime()+ "| "+"Error. No Coordinates found."
    sys.exit(EXIT_FAILURE)

for i in range(len(coords)):
    coords[i] = [coords[i].strip().split()[0],
                 float(coords[i].strip().split()[1]),
                 float(coords[i].strip().split()[2]),
                 float(coords[i].strip().split()[3])]

#Read in Indexes from ORDER file and sort into integers
#NOTE: Re-writing over the original index maintains the data type
#      new_index used to avoid this

index = f3.readlines()
for i in range(len(index)):
    new_index.append(int(index[i].strip("\n")))


#Read in unit vectors
unitvecs = []
for i in range(3):
    unitvecs.append(f4.readline().split())

f1.close()
f2.close()
f3.close()
f4.close()

#Check to make sure everything is in order, and that the len of the coords list is the same as the index and charge list
#If this fails, there is something wrong with the files thus far.
if((len(rpt_charges)!=len(coords))or(len(rpt_charges)!=len(index))):
    print " ["+pid+"] "+time.ctime()+ "| "+"Something is very wrong. Check code"
    sys.exit(EXIT_FAILURE)

#Amalgomate lists into one master reference list "fullfixed" 
#and retain original order of atoms for user clarity.

fullfixed = index
count=0
for i in range(len(index)):
    atomno=new_index[i]-1    
    fullfixed[atomno]=[coords[atomno][0],float(coords[atomno][1]),float(coords[atomno][2]),float(coords[atomno][3]),float(rpt_charges[atomno])]


#######################################
# Beginning of CONFIG file Generation #
#######################################

#Write Header of CONFIG file
CONFIG_FILE.write(sys.argv[1]+" "+str(DLPOLY_SUPERCELL_DIMS[0])+"X"+str(DLPOLY_SUPERCELL_DIMS[1])+"X"+str(DLPOLY_SUPERCELL_DIMS[2])+" Supercell\n")


CONFIG_FILE.write("%(lvc)10i%(imcn)10i%(ssatms)10i\n" % {'lvc' : DLPOLY_LEVCFG , 'imcn' : DLPOLY_IMCON , 'ssatms' : len(fullfixed)*DLPOLY_SUPERCELL_DIMS[0]*DLPOLY_SUPERCELL_DIMS[1]*DLPOLY_SUPERCELL_DIMS[2]}) 
#print " ["+pid+"] "+time.ctime()+ "| "+unitvecs
for i in range(3):
    CONFIG_FILE.write("%(v_a)20.12f%(v_b)20.12f%(v_c)20.12f\n" % {"v_a" : DLPOLY_SUPERCELL_DIMS[i]*float(unitvecs[i][0]),"v_b" : DLPOLY_SUPERCELL_DIMS[i]*float(unitvecs[i][1]),"v_c" : DLPOLY_SUPERCELL_DIMS[i]*float(unitvecs[i][2])})

#import the GUEST information from the GUEST_FILE
guest_atoms = []
GCOORDS = []
GUEST = GUEST_FILE.readlines()
GUEST_FILE.close()
global finish_found
finish_found = False
for i in range(len(GUEST)):
    print " ["+pid+"] "+time.ctime()+ "| "+str(finish_found)
    if not(finish_found):
        guest_atoms.append(GUEST[3+i].strip(' ').split())
        print " ["+pid+"] "+time.ctime()+ "| "+GUEST[3+i]
    if (GUEST[6+i].strip().upper() == "FINISH"):
        finish_found = True
        print " ["+pid+"] "+time.ctime()+ "| "+"CHANGE"
        break

if not(finish_found):
    print " ["+pid+"] "+time.ctime()+ "| "+"Guest file not formatted correctly.  See documentation."
    sys.exit(EXIT_FAILURE)
print " ["+pid+"] "+time.ctime()+ "| "+"-"*80
print " ["+pid+"] "+time.ctime()+ "| "+str(guest_atoms)
print " ["+pid+"] "+time.ctime()+ "| "+"-"*80


#Pull in Guest co-ordinates
SWITCH = 0
for i in range(len(GUEST)):
    if SWITCH:
        GCOORDS.append(GUEST[i].split())
    if (GUEST[i].strip().upper() == "FINISH"):
        SWITCH = 1

FAST_GUEST_FIELD_ATOMS = guest_atoms[:]
for i in range(len(FAST_GUEST_FIELD_ATOMS)):
    for j in range(3):
        FAST_GUEST_FIELD_ATOMS[i].append(GCOORDS[i][j+1])

print " ["+pid+"] "+time.ctime()+ "| "+str(FAST_GUEST_FIELD_ATOMS)

for i in range(len(FAST_GUEST_FIELD_ATOMS)):
    templine = ""
    for j in range(len(FAST_GUEST_FIELD_ATOMS[i])):
        templine+=FAST_GUEST_FIELD_ATOMS[i][j]+" "
    templine+="\n"
    FAST_GUEST_FIELD_ATOMS[i] = templine

FAST_GUEST_FIELD_SECTION = GUEST[:3]   

for i in range(len(FAST_GUEST_FIELD_ATOMS)):
    FAST_GUEST_FIELD_SECTION.append(FAST_GUEST_FIELD_ATOMS[i])

print " ["+pid+"] "+time.ctime()+ "| "+str(FAST_GUEST_FIELD_SECTION)

###

#Probe for best Guest location

#function to return vector length
def vlength(coordinate):
    offset = (len(coordinate)-3)
    return ((float(coordinate[0+offset])*float(coordinate[0+offset]))+(float(coordinate[1+offset])*float(coordinate[1+offset]))+(float(coordinate[2+offset])*float(coordinate[2+offset])))

#function to return vector difference
def vdiff(coords1, coords2):
    ofst1 = (len(coords1)-3)
    ofst2 = (len(coords2)-3)
    return [float(coords1[0+ofst1])-float(coords2[0+ofst2]),float(coords1[1+ofst1])-float(coords2[1+ofst2]),float(coords1[2+ofst1])-float(coords2[2+ofst2])]

#function to return vector summation
def vsum(coords1, coords2):
    ofst1 = (len(coords1)-3)
    ofst2 = (len(coords2)-3)
    return [float(coords1[0+ofst1])+float(coords2[0+ofst2]),float(coords1[1+ofst1])+float(coords2[1+ofst2]),float(coords1[2+ofst1])+float(coords2[2+ofst2])]

#function to multiply vector by a scalar
def vmult(coords1, factor):
    ofst1 = (len(coords1)-3)
    return [float(coords1[0+ofst1])*factor,float(coords1[1+ofst1])*factor,float(coords1[2+ofst1])*factor]


#function to return centroid of multiple points in space
def Centroid(coordset):
    centroid = [0,0,0]
    for i in range(len(coordset)):
        for j in range(3):
            centroid[j]+=float(coordset[i][j+1])
    for i in range(3):
        centroid[i] = centroid[i]/len(coordset)
    return centroid

GUEST_CENTROID = Centroid(GCOORDS)



#function to return the index of the closest point to a reference point within a set of points
def closestvecto(coordset,reference_point):
    closest_index = -1
    min_dist = 999999
    for i in range(len(coordset)):
        if(vlength(vdiff(coordset[i],reference_point)) < min_dist):
            min_dist = vlength(vdiff(coordset[i],reference_point))
            closest_index = i
    return closest_index

centremost_index = closestvecto(GCOORDS,GUEST_CENTROID)


rGCOORDS = []

for i in range(len(GCOORDS)):
    rGCOORDS.append([GCOORDS[i][0]]+vdiff(GCOORDS[centremost_index],GCOORDS[i]))

#print " ["+pid+"] "+time.ctime()+ "| "+rGCOORDS


incra = []
incrb = []
incrc = []

#initialize the incrementation vectors used to propagate through the cell space
for i in range(3):
    incra.append(float(unitvecs[0][i])/DLPOLY_GUEST_GRIDPOINTS)
    incrb.append(float(unitvecs[1][i])/DLPOLY_GUEST_GRIDPOINTS)
    incrc.append(float(unitvecs[2][i])/DLPOLY_GUEST_GRIDPOINTS)

#print " ["+pid+"] "+time.ctime()+ "| "+incra
#print " ["+pid+"] "+time.ctime()+ "| "+unitvecs[0]

#square the compared distance instead of square rooting the resulting distance vector
DLPOLY_MIN_GUEST_DISTANCE *= DLPOLY_MIN_GUEST_DISTANCE

#function to check if distance between guest and surrounding is less than DLPOLY_MIN_GUEST_DISTANCE
def chkguest(guest,coordset):
    Fail = 0
    for i in range(len(coordset)):
        if (vlength(vdiff(guest,coordset[i])) < DLPOLY_MIN_GUEST_DISTANCE):
            Fail = 1
            break;
    return Fail
   
trialguest = []
goodguest = []

#engine of guest placement functionality
#moves the guest through the cell and checks each location to see if it fits

for gaa in range(int(DLPOLY_GUEST_GRIDPOINTS)):
    for gbb in range(int(DLPOLY_GUEST_GRIDPOINTS)):
        for gcc in range(int(DLPOLY_GUEST_GRIDPOINTS)):
            trialguest = vsum(rGCOORDS[centremost_index],vsum(vsum(vmult(incra,gaa),vmult(incrb,gbb)),vmult(incrc,gcc)))
            if not(chkguest(trialguest,coords)):
                for i in range(len(rGCOORDS)):
                    if(chkguest(vsum(trialguest,rGCOORDS[i]),coords)):
                        break;
                goodguest = trialguest
                break;


#Write the Guest molecule part of the DL_POLY input file for GCMC

COUNTER=1

for i in range(len(GCOORDS)):
    curr_atom = [GCOORDS[i][0]]+vsum(goodguest,rGCOORDS[i])
    CONFIG_FILE.write(curr_atom[0].ljust(8)+"%(CNT)10i\n" % {'CNT' : COUNTER })
    CONFIG_FILE.write("%(vecx)20.12f%(vecy)20.12f%(vecz)20.12f\n" % {'vecx' : float(curr_atom[1]),'vecy' : float(curr_atom[2]),'vecz' :float(curr_atom[3])})
    COUNTER+=1

#print " ["+pid+"] "+time.ctime()+ "| "+unitvecs


#print " ["+pid+"] "+time.ctime()+ "| "+unitvecs
#print " ["+pid+"] "+time.ctime()+ "| "+mult
#print " ["+pid+"] "+time.ctime()+ "| "+fullfixed


#Process through interations of supercell projection coordinates
#Write the rest of the CONFIG file
for naa in range(DLPOLY_SUPERCELL_DIMS[0]):
    for nbb in range(DLPOLY_SUPERCELL_DIMS[1]):
        for ncc in range(DLPOLY_SUPERCELL_DIMS[2]):
            vect_add=[naa*float(unitvecs[0][0])+nbb*float(unitvecs[1][0])+ncc*float(unitvecs[2][0]),
                      naa*float(unitvecs[0][1])+nbb*float(unitvecs[1][1])+ncc*float(unitvecs[2][1]),
                      naa*float(unitvecs[0][2])+nbb*float(unitvecs[1][2])+ncc*float(unitvecs[2][2])]
            for i in range(len(fullfixed)):
                CONFIG_FILE.write(fullfixed[i][0].ljust(8)+"%(CNT)10i\n" % {'CNT' : COUNTER }) 
                CONFIG_FILE.write("%(vecx)20.12f%(vecy)20.12f%(vecz)20.12f\n" % {'vecx' : fullfixed[i][1]+vect_add[0],'vecy' : fullfixed[i][2]+vect_add[1],'vecz' : fullfixed[i][3]+vect_add[2]})
                COUNTER+=1

print " ["+pid+"] "+time.ctime()+ "| "+"CONFIG file Written"

CONFIG_FILE.close()




######################################
# Beginning of FIELD file Generation #
######################################

#Import VDW LJ parameters from file
vdw_vals = VDW_FILE.readlines()
for i in range(len(vdw_vals)):
    vdw_vals[i] = vdw_vals[i].split()
VDW_FILE.close()

vdw_elements =[]




#turn off to define custom CDW values in UFF table
relabel(guest_atoms,elements)


for i in range(len(GCOORDS)):
    vdw_elements.append(GCOORDS[i][0])

for i in range(len(fullfixed)):
    vdw_elements.append(fullfixed[i][0])

vdw_elements=uniqify(vdw_elements)


# Begin writing of FIELD FILE.
def write_GCMC_FIELD():
    FIELD_FILE.write("Simulation of "+sys.argv[1]+ "supercell\n")
    FIELD_FILE.write("UNITS   kcal\n")
    FIELD_FILE.write("molecular types "+str(DLPOLY_MOL_TYPES)+"\n")
    
    
    for i in range(len(GUEST)):
        FIELD_FILE.write(GUEST[i])
        if (GUEST[i].strip().upper() == "FINISH"):
            break
    
    FIELD_FILE.write("Frozen "+sys.argv[1]+" framework\nNUMMOLS "+str(DLPOLY_SUPERCELL_DIMS[0]*DLPOLY_SUPERCELL_DIMS[1]*DLPOLY_SUPERCELL_DIMS[2])+"\nATOMS "+str(len(fullfixed))+"\n")
    for i in range(len(fullfixed)):
        FIELD_FILE.write(fullfixed[i][0].ljust(8)+ "%(weight)13.4f%(charge)9.4f    1   1\n" % {'weight' : float(lookupwt(fullfixed[i][0])), 'charge' : float(fullfixed[i][4])})
    FIELD_FILE.write("finish\nVDW")
    FIELD_FILE.write(str(((len(vdw_elements)**2)+len(vdw_elements))/2).rjust(4)+"\n")
    
    
    #for i in range(len(elements)):
    #  print " ["+pid+"] "+time.ctime()+ "| "+elements[i],":  ",getvdwline(elements[i])
    
    
    
    for i in range(len(vdw_elements)):
        for j in range(i+1):
            mixed_sigma = (float(getvdwline(vdw_elements[i])[1])+float(getvdwline(vdw_elements[j])[1]))/2.0 
            mixed_epsilon = (float(getvdwline(vdw_elements[i])[2])*float(getvdwline(vdw_elements[j])[2]))**(1/2.0) 
            FIELD_FILE.write(vdw_elements[i].ljust(8)+vdw_elements[j].ljust(8)+"lj  %(B)8.5f%(A)8.5f\n" % { 'A' : mixed_sigma , 'B' : mixed_epsilon})
    
    FIELD_FILE.write("close")
    #FIELD file finished writing
    FIELD_FILE.close()




FAST_NUM_GUESTS = int(init_variable("FAST_NUM_GUESTS"))

def write_fastGCMC_FIELD():
    FIELD_FILE.write("Simulation of "+sys.argv[1]+ "supercell\n")
    FIELD_FILE.write("UNITS   kcal\n")
    FIELD_FILE.write("molecular types "+str(DLPOLY_MOL_TYPES)+"\n&guest ")
 
   
    for i in range(len(FAST_GUEST_FIELD_SECTION)):
        FIELD_FILE.write(FAST_GUEST_FIELD_SECTION[i])
    FIELD_FILE.write("finish\n")
    
    FIELD_FILE.write("Frozen "+sys.argv[1]+" framework\nNUMMOLS "+str(DLPOLY_SUPERCELL_DIMS[0]*DLPOLY_SUPERCELL_DIMS[1]*DLPOLY_SUPERCELL_DIMS[2])+"\nATOMS "+str(len(fullfixed))+"\n")
    for i in range(len(fullfixed)):
        FIELD_FILE.write(fullfixed[i][0].ljust(8)+ "%(weight)13.4f%(charge)9.4f    1   1\n" % {'weight' : float(lookupwt(fullfixed[i][0])), 'charge' : float(fullfixed[i][4])})
    FIELD_FILE.write("finish\nVDW")
    FIELD_FILE.write(str(((len(vdw_elements)**2)+len(vdw_elements))/2).rjust(4)+"\n")
    
    
    #for i in range(len(elements)):
    #  print " ["+pid+"] "+time.ctime()+ "| "+elements[i],":  ",getvdwline(elements[i])
    
    
    
    for i in range(len(vdw_elements)):
        for j in range(i+1):
            mixed_sigma = (float(getvdwline(vdw_elements[i])[1])+float(getvdwline(vdw_elements[j])[1]))/2.0 
            mixed_epsilon = (float(getvdwline(vdw_elements[i])[2])*float(getvdwline(vdw_elements[j])[2]))**(1/2.0) 
            FIELD_FILE.write(vdw_elements[i].ljust(8)+vdw_elements[j].ljust(8)+"lj  %(B)8.5f%(A)8.5f\n" % { 'A' : mixed_sigma , 'B' : mixed_epsilon})
    
    FIELD_FILE.write("close")
    #FIELD file finished writing
    FIELD_FILE.close()


if MAIN_GCMC_PACKAGE == "DLPOLY":
    write_GCMC_FIELD()
elif MAIN_GCMC_PACKAGE == "FASTGCMC":
    write_fastGCMC_FIELD()

########################################
# Beginning of CONTROL file Generation #
########################################
# !!NOTE: CONTROL file (over)/writing subject to options in JOB_INPUT.


#init some FASTGCMC variables if FAST is being used.
if MAIN_GCMC_PACKAGE == "FASTGCMC":
    FAST_PP_G1 = init_variable("FAST_PP_G1")
    FAST_PP_G2 = init_variable("FAST_PP_G2")
    FAST_PP_G3 = init_variable("FAST_PP_G3")
    FAST_SIM_LENGTH = init_variable("FAST_SIM_LENGTH")
    FAST_EQ_TIME = init_variable("FAST_EQ_TIME")
    partial_pressures = [FAST_PP_G1,FAST_PP_G2,FAST_PP_G3]
    DLPOLY_MOL_TYPES=str(int(DLPOLY_MOL_TYPES)+int(FAST_NUM_GUESTS))
    FAST_GUEST_SECTION = '''
'''
    for i in range(FAST_NUM_GUESTS):
        FAST_GUEST_SECTION+='''
&guest '''+str(i+1)+'''
  pressure (bar)           '''+str(partial_pressures[i])+'''
&end
'''

FAST_EQ_TIME = init_variable("FAST_EQ_TIME")
FAST_SIM_LENGTH = init_variable("FAST_SIM_LENGTH")

FAST_EQUIL_PART = '''
#First do this number of steps (for each node)
equilibration             '''+FAST_EQ_TIME+'''

# Simulation length and equilibration steps that count towards average. (over all nodes)
steps                     '''+FAST_SIM_LENGTH+'''
'''


CONTROL_part1 = '''GCMC

# The state point
temperature                '''

CONTROL_part2a =           '''
pressure (kbar)            '''

CONTROL_part2ba = '''

# Simulation length and equilibration
steps                     1
equilibration             1
timestep                0.00050 ps
scale every 5

# ensemble options
ensemble  nvt hoover        0.1
'''
CONTROL_part2bb='''
# specify cutoffs
cutoff                   '''
CONTROL_part3a = ''' angstrom

# print controller
print 1
stats  1

# rdf options
#rdf                 100
#print rdf

# job time and permitted wind-up time
job time 19999990 seconds
close time     2000 seconds
'''
CONTROL_part3b='''
# dealing with coulombic forces
ewald precision  '''
CONTROL_part4 = '''

# trajectory details
#traj 100000,100,0

finish
'''

#Taking the Pressure from GCMC in Pascal and putting in kbar for CONTROL file
CONTROL_PRESSURE = str(int(init_variable("GCMC_IDEAL_GAS_PRESSURE")) * 10E-8)
DL_POLY_CONTROL_TEMP = str(int(init_variable("DL_POLY_CONTROL_TEMP"))) 
DL_POLY_CUTOFF = str(init_variable("DL_POLY_CUTOFF"))
DLPOLY_DELR = str(init_variable("DLPOLY_DELR"))
DL_POLY_EWALD_PRECISION = str(init_variable("DL_POLY_EWALD_PRECISION"))


AO_CONTROL_USE=str(init_variable("AO_CONTROL_USE")).upper() 

def write_GCMC_CONTROL():
    CONTROL_FILE = open("CONTROL",'w')
    CONTROL_FILE.write(CONTROL_part1+DL_POLY_CONTROL_TEMP+CONTROL_part2a+CONTROL_PRESSURE+CONTROL_part2ba+CONTROL_part2bb+DL_POLY_CUTOFF+"angstrom\ndelr                     "+DLPOLY_DELR+CONTROL_part3a+CONTROL_part3b+DL_POLY_EWALD_PRECISION+CONTROL_part4)
    CONTROL_FILE.close()

def write_fastGCMC_CONTROL():
    CONTROL_FILE = open("CONTROL",'w')   
    CONTROL_FILE.write(CONTROL_part1+DL_POLY_CONTROL_TEMP+FAST_GUEST_SECTION+FAST_EQUIL_PART+CONTROL_part2bb+DL_POLY_CUTOFF+"\ndelr                     "+DLPOLY_DELR+"\n"+CONTROL_part3b+DL_POLY_EWALD_PRECISION+"\nfinish")
    CONTROL_FILE.close()

if MAIN_GCMC_PACKAGE == "DLPOLY":
    write_CONTROL = write_GCMC_CONTROL
elif MAIN_GCMC_PACKAGE == "FASTGCMC":
    write_CONTROL = write_fastGCMC_CONTROL

if os.path.exists("./CONTROL"):
    if AO_CONTROL_USE == "BACKUP":
        print " ["+pid+"] "+time.ctime()+ "| "+"Backing up current CONTROL file to CONTROL.bak"
        os.popen("mv CONTROL CONTROL.bak")
        write_CONTROL()
    elif AO_CONTROL_USE == "USE":
        print " ["+pid+"] "+time.ctime()+ "| "+"Using CONTROL file allready present. AO_CONTROL_USE set to USE.\nBypassing generation of new CONTROL file."        
    elif AO_CONTROL_USE == "OVERWRITE":
        print " ["+pid+"] "+time.ctime()+ "| "+"Generating new CONTROL file. Overwriting present CONTROL file."
        write_CONTROL()
else:
    print " ["+pid+"] "+time.ctime()+ "| "+"No CONTROL file present.\nGenerating new CONTROL file from JOB_INPUT params."
    write_CONTROL()







vardump(dir())
