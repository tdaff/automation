#!/usr/bin/env python
import os
import sys
import time
import subprocess
from JOB_OPTIONS import *


pid = str(os.getpid())

EXIT_SUCCESS = 0
EXIT_FAILURE = 1

#The purpose of this script is to wrap a CPMD job
#It delays processing until CPMD has finished
#It takes two arguments
#1: The name of the CPMD input file
#2: The number of processors to run the job on

usage  = '''
---------------------------------------------------
Usage:
02subcpmd_wrapper [CPMD INPUT filename] [# proc]
---------------------------------------------------
'''

#check if there are enough arguments in the call to main

#Checking for arguments array size
if(len(sys.argv)!=3):
    print " ["+pid+"] "+time.ctime()+ "| "+"Too many/few arguments"
    sys.exit(EXIT_FAILURE)

dump = True
basevars = dir()

def vardump(newvars):
    if dump:
	for varname in basevars:
            newvars.remove(str(varname))
        for possiblefunction in newvars:
            if str(eval(str(possiblefunction))).__contains__("0x"):
                newvars.remove(str(possiblefunction))
        for possiblefunction in newvars:
            if str(eval(str(possiblefunction))).__contains__("0x"):
                newvars.remove(str(possiblefunction))
        for newvarname in newvars:
            print "#dump#%(name)35s evaluates to | %(eval)35s" % {'name':newvarname,'eval':eval(newvarname)}




try: 
    user = os.popen('whoami').readline().split()[0]
except:
    print " ["+pid+"] "+time.ctime()+ "| "+"Could not get username from system"
    sys.exit(EXIT_FAILURE)

cpmd_input =  sys.argv[1]
CHECK_FOR_COMPLETE = False



# function added to see if the cpmd program terminated succesfully, added for restart purposes
def cpmdcheck():
    if os.path.exists("/shared_scratch/"+user+'/'+cpmd_input):
        cpmdlist=os.listdir("/shared_scratch/"+user+'/'+cpmd_input)
        if 'output' in cpmdlist:
            donecheck=int(subprocess.Popen("grep -c 'FINAL' /shared_scratch/"+user+"/"+cpmd_input+"/output",stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True).stdout.readline())
            if donecheck>0:
                return True
            else:
                return False
        else:
            return False
    else:
        return False

if CHECK_FOR_COMPLETE:
    cpmdcheck()

#Functions which queries qstat for jobID, returns 1 if found, 0 if not.
def qexists(jobID):
    qlist = subprocess.Popen('qstat',stdout=subprocess.PIPE,shell=True).stdout
    first_line = qlist.readline()
    if not(first_line.split() == ['Job', 'id', 'Name', 'User', 'Time', 'Use', 'S', 'Queue']):
        print " ["+pid+"] "+time.ctime()+ "| "+"\nProblem with qstat. Not returning jobs.  Waiting . . \n"
        found=1
        return found
    qlist.readline()
    all_jobs = qlist.readlines()
    found = 0
    if len(all_jobs) == 0:
        print " ["+pid+"] "+time.ctime()+ "| "+"Error. Submit script not outputting. Can't grab JobID"
        sys.exit(EXIT_FAILURE)
    job_found = False
    for i in range(len(all_jobs)):
        if(all_jobs[i].split(".")[0]==str(job_id)) :
            found+=1
    return found

#Runs cpmdsubmit and pulls job ID from standard out.
cpmd_outstream = subprocess.Popen('cpmdsubmit '+sys.argv[1]+' '+sys.argv[2],stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True).stdout.readlines()
job_id = "x.x"
print " ["+pid+"] "+time.ctime()+ "| "+"-"*80
print " ["+pid+"] "+time.ctime()+ "| "+str(cpmd_outstream)
print " ["+pid+"] "+time.ctime()+ "| "+"-"*80
job_found = False
for i in range(len(cpmd_outstream)):
    if cpmd_outstream[i].__contains__("wooki"):
        job_id = cpmd_outstream[i].split(".")[0]
        job_found = True

if not(job_found):
    print " ["+pid+"] "+time.ctime()+ "| "+"Error. Job ID not returned in submit script output."
    sys.exit(EXIT_FAILURE)


#Sleeps while job still exists
while(qexists(job_id)):
    time.sleep(10)

vardump(dir())
