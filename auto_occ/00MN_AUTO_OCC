#!/usr/bin/env python
import os
import sys
import time 
import md5
from JOB_OPTIONS import *

pid = str(os.getpid())

EXIT_SUCCESS = 0
EXIT_FAILURE = 1

#This python script runs each of the other scripts and carries the appropriate arguements throughout the process.
#Eventually it will have to be replaced by a simpler more intuitive model, however for debugging and modularity purposes,
#this is how the code is currently being run.

usage  = '''
---------------------------------------------------
Usage:
00MN_AUTO_OCC [XYZ_INPUT filename] [JOBNAME]
---------------------------------------------------
'''



#Generate a UUID to append to jobs in event that name is the same
#UUID = md5.md5(time.ctime()+str(time.sleep(1))).hexdigest()[:10]
#UUID = ""

TESTING = 1
if TESTING:
    source_dir ="./"
else:
    source_dir =os.popen("echo $HOME").read().strip()+"/bin/" 

#check if there are enough arguments in the call to main
if len(sys.argv) < 3:
    print " ["+pid+"] "+time.ctime()+ "| "+"Too Few Arguments"
    print " ["+pid+"] "+time.ctime()+ "| "+usage
    sys.exit(EXIT_FAILURE)

#Check to see if cpmd.in parameter is correct, if not, add .in extension
if sys.argv[2].rfind(".in") > -1:
  sys.argv[2] = sys.argv[2].split(".")[0]
  print " ["+pid+"] "+time.ctime()+ "| "+"Removing \".\" from input file name\n"

#print " ["+pid+"] "+time.ctime()+ "| "+"Suffixing uuid to run name"
#sys.argv[2] = sys.argv[2].split(".")[0]+"_"+str(UUID)

#Define number of processors to be used in the CPMD run.
CPMD_NUM_PROCESSORS = init_variable("CPMD_NUM_PROCESSORS")

MAIN_ENABLE_SCHEDULE = init_variable("MAIN_ENABLE_SCHEDULE")


######################
### BEGIN OF CALLS ###
######################


def call_01mkcpmd():
    #Call to make CPMD input file with arguments for xyz input file, and name of CPMD input file
    #eg. 01mkcdpmd ZIF21_INPUT.xyz  ZIF21.in
    print " ["+pid+"] "+time.ctime()+ "| "+"--Making CPMD file"
    try:
        if os.system(source_dir+'01mkcpmd '+sys.argv[1]+' '+sys.argv[2]) != EXIT_SUCCESS:
            print " ["+pid+"] "+time.ctime()+ "| "+"-"*60+"\nSubroutine 01mkcpmd did not exit successfully.\n"+"-"*60
            sys.exit(EXIT_FAILURE)
    except:
        print " ["+pid+"] "+time.ctime()+ "| "+"\nExiting."
        sys.exit(EXIT_FAILURE)
    print " ["+pid+"] "+time.ctime()+ "| "+"--Done making CPMD file"

def call_02cpmd_wrapper():

    #Call to CPMD wrapper program for running CPMD on 02subcpmd_wrapper argument 1 using nproc processors and wait till job is complete.
    # eg. 02subcpmd_wrapper ZIF21 
    print " ["+pid+"] "+time.ctime()+ "| "+"--Calling CPMD Wrapper\n"
    try:
        if os.system(source_dir+'02subcpmd_wrapper '+sys.argv[2]+' '+str(CPMD_NUM_PROCESSORS)) != EXIT_SUCCESS:
            print " ["+pid+"] "+time.ctime()+ "| "+"-"*60+"\nSubroutine 02subcpmd_wrapper did not exit successfully.\n"+"-"*60
            sys.exit(EXIT_FAILURE)
    except:
        print " ["+pid+"] "+time.ctime()+ "| "+"\nExiting."
        sys.exit(EXIT_FAILURE)
    print " ["+pid+"] "+time.ctime()+ "| "+"--CPMD wrapper finished\n"

def call_03_get_REPEAT_charges():
    print " ["+pid+"] "+time.ctime()+ "| "+"Getting Charges Through REPEAT"
    try:
        if os.system(source_dir+"03get_REPEAT_charges "+sys.argv[2]) != EXIT_SUCCESS:
            print " ["+pid+"] "+time.ctime()+ "| "+"-"*60+"\nSubroutine 03get_REPEAT_charges did not exit successfully.\n"+"-"*60
            sys.exit(EXIT_FAILURE)
    except:
        print " ["+pid+"] "+time.ctime()+ "| "+"\nExiting."
        sys.exit(EXIT_FAILURE)
    print " ["+pid+"] "+time.ctime()+ "| "+"REPEAT Charges finished"

def call_04mkdlpolyin():
    #Call to 04mkdlpolyin to make the CONFIG FIELD and CONTROL files for GCMC automation 
    print " ["+pid+"] "+time.ctime()+ "| "+"--Making DL_POLY files"
    try: 
        if os.system(source_dir+'04mkdlpolyin '+sys.argv[2]) != EXIT_SUCCESS:
            print " ["+pid+"] "+time.ctime()+ "| "+"-"*60+"\nSubroutine 04mkdlpolyin did not exit successfully.\n"+"-"*60
            sys.exit(EXIT_FAILURE)
    except:
        print " ["+pid+"] "+time.ctime()+ "| "+"\nExiting."
        sys.exit(EXIT_FAILURE)
    print " ["+pid+"] "+time.ctime()+ "| "+"\n--DL_POLY files done"



def call_05CREATE_GCMC_FRAME():
    #Call to generate GCMC directory framework and run GCMC machinery
    try:
        if os.system(source_dir+'05CREATE_GCMC_FRAME '+sys.argv[2])!= EXIT_SUCCESS:
            print " ["+pid+"] "+time.ctime()+ "| "+"-"*60+"\nSubroutine 05CREATE_GCMC_FRAME did not exit successfully.\n"+"-"*60
            sys.exit(EXIT_FAILURE)
    except:
        print " ["+pid+"] "+time.ctime()+ "| "+"\nExiting."
        sys.exit(EXIT_FAILURE)

def call_06GCMC_wrapper():
    #Call to generate GCMC directory framework and run GCMC machinery
    try:
        if os.system(source_dir+'06GCMC_wrapper '+sys.argv[2])!= EXIT_SUCCESS:
            print " ["+pid+"] "+time.ctime()+ "| "+"-"*60+"\nSubroutine 06GCMC_wrapper did not exit successfully.\n"+"-"*60
            sys.exit(EXIT_FAILURE)
    except:
        print " ["+pid+"] "+time.ctime()+ "| "+"\nExiting."
        sys.exit(EXIT_FAILURE)

def execute_schedule():
    schedule_file = open("./SCHEDULE",'r')
    SCHEDULE = schedule_file.read()
    schedule_file.close()



if MAIN_ENABLE_SCHEDULE == "ENABLE":
    execute_schedule()
else:
    if not(os.path.exists("./FRAMEWORK_COMPLETE")):
        call_01mkcpmd()
        call_02cpmd_wrapper()
        call_03_get_REPEAT_charges()
        os.system("touch FRAMEWORK_COMPLETE")
    call_04mkdlpolyin()
    call_05CREATE_GCMC_FRAME()
    call_06GCMC_wrapper()

